{"version":3,"file":"static/js/992.982e5987.chunk.js","mappings":"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","sources":["../node_modules/pixi.js/src/scene/graphics/gpu/GpuGraphicsAdaptor.ts","../node_modules/pixi.js/src/scene/mesh/gpu/GpuMeshAdapter.ts","../node_modules/pixi.js/src/rendering/batcher/gpu/GpuBatchAdaptor.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/BindGroupSystem.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/buffer/GpuBufferSystem.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/GpuColorMaskSystem.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/GpuDeviceSystem.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/GpuEncoderSystem.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/GpuLimitsSystem.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/GpuStencilSystem.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/GpuUboSystem.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/buffer/UboBatch.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/GpuUniformBatchPipe.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/pipeline/PipelineSystem.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTarget.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuShaderSystem.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuBlendModesToPixi.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStateSystem.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/texture/GpuTextureSystem.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/WebGPURenderer.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { type Renderer } from '../../../rendering/renderers/types';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { GpuEncoderSystem } from '../../../rendering/renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipe } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses the GPU to render graphics.\n * @category rendering\n * @ignore\n */\nexport class GpuGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    private _maxTextures = 0;\n\n    public contextChange(renderer: Renderer): void\n    {\n        const localUniforms = new UniformGroup({\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        this._maxTextures = renderer.limits.maxBatchableTextures;\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'graphics',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(this._maxTextures),\n\n                localUniformBitGroup2,\n                roundPixelsBit\n            ]\n        });\n\n        this.shader = new Shader({\n            gpuProgram,\n            resources: {\n                // added on the fly!\n                localUniforms,\n            },\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGPURenderer;\n        const contextSystem = renderer.graphicsContext;\n\n        const {\n            batcher, instructions\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGPU specific...\n\n        // TODO perf test this a bit...\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        encoder.setGeometry(batcher.geometry, shader.gpuProgram);\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n\n        const localBindGroup = (renderer as WebGPURenderer)\n            .renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n\n        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        let topology: Topology = null;\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            if (batch.topology !== topology)\n            {\n                topology = batch.topology;\n\n                encoder.setPipelineFromGeometryProgramAndState(\n                    batcher.geometry,\n                    shader.gpuProgram,\n                    graphicsPipe.state,\n                    batch.topology\n                );\n            }\n\n            shader.groups[1] = batch.bindGroup;\n\n            if (!batch.gpuBindGroup)\n            {\n                const textureBatch = batch.textures;\n\n                batch.bindGroup = getTextureBatchBindGroup(\n                    textureBatch.textures,\n                    textureBatch.count,\n                    this._maxTextures\n                );\n\n                batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n                    batch.bindGroup, shader.gpuProgram, 1\n                );\n            }\n\n            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n\n            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { textureBit } from '../../../rendering/high-shader/shader-bits/textureBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Mesh } from '../shared/Mesh';\nimport type { MeshAdaptor, MeshPipe } from '../shared/MeshPipe';\n\n/**\n * The WebGL adaptor for the mesh system. Allows the Mesh System to be used with the WebGl renderer\n * @category rendering\n * @ignore\n */\nexport class GpuMeshAdapter implements MeshAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'mesh',\n    } as const;\n\n    private _shader: Shader;\n\n    public init(): void\n    {\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'mesh',\n            bits: [\n                localUniformBit,\n                textureBit,\n                roundPixelsBit,\n            ]\n        });\n\n        this._shader = new Shader({\n            gpuProgram,\n            resources: {\n                uTexture: Texture.EMPTY._source,\n                uSampler: Texture.EMPTY._source.style,\n                textureUniforms: {\n                    uTextureMatrix: { type: 'mat3x3<f32>', value: new Matrix() },\n                }\n            }\n        });\n    }\n\n    public execute(meshPipe: MeshPipe, mesh: Mesh)\n    {\n        const renderer = meshPipe.renderer as WebGPURenderer;\n\n        let shader: Shader = mesh._shader;\n\n        if (!shader)\n        {\n            shader = this._shader;\n\n            shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);\n        }\n        else if (!shader.gpuProgram)\n        {\n            // #if _DEBUG\n            warn('Mesh shader has no gpuProgram', mesh.shader);\n            // #endif\n\n            return;\n        }\n\n        const gpuProgram = shader.gpuProgram;\n        // GPU..\n\n        if (gpuProgram.autoAssignGlobalUniforms)\n        {\n            shader.groups[0] = renderer.globalUniforms.bindGroup;\n        }\n\n        if (gpuProgram.autoAssignLocalUniforms)\n        {\n            const localUniforms = meshPipe.localUniforms;\n\n            shader.groups[1] = (renderer as WebGPURenderer)\n                .renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n        }\n\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader,\n            state: mesh.state\n        });\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup';\n\nimport type { GpuEncoderSystem } from '../../renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../renderers/gpu/WebGPURenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\nconst tempState = State.for2d();\n\n/**\n * A BatcherAdaptor that uses the GPU to render batches.\n * @category rendering\n * @ignore\n */\nexport class GpuBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private _shader: Shader;\n    private _geometry: Geometry;\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    {\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n        const program = shader.gpuProgram;\n\n        this._shader = shader;\n        this._geometry = geometry;\n\n        encoder.setGeometry(geometry, program);\n\n        tempState.blendMode = 'normal';\n\n        // this just initiates the pipeline, so we can then set bind groups on it\n        renderer.pipeline.getPipeline(\n            geometry,\n            program,\n            tempState\n        );\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        // low level - we need to reset the bind group at location 1 to null\n        // this is because we directly manipulate the bound buffer in the execute function for\n        // performance reasons.\n        // setting it to null ensures that the next bind group we set at location 1 will\n        // be the one we want.\n        encoder.resetBindGroup(1);\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, program);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const program = this._shader.gpuProgram;\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        if (!batch.bindGroup)\n        {\n            const textureBatch = batch.textures;\n\n            batch.bindGroup = getTextureBatchBindGroup(\n                textureBatch.textures,\n                textureBatch.count,\n                renderer.limits.maxBatchableTextures\n            );\n        }\n\n        tempState.blendMode = batch.blendMode;\n\n        const gpuBindGroup = renderer.bindGroup.getBindGroup(\n            batch.bindGroup, program, 1\n        );\n\n        const pipeline = renderer.pipeline.getPipeline(\n            this._geometry,\n            program,\n            tempState,\n            batch.topology\n        );\n\n        batch.bindGroup._touch(renderer.textureGC.count);\n\n        encoder.setPipeline(pipeline);\n\n        encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { BufferResource } from '../shared/buffer/BufferResource';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { System } from '../shared/system/System';\nimport type { TextureSource } from '../shared/texture/sources/TextureSource';\nimport type { TextureStyle } from '../shared/texture/TextureStyle';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { BindResource } from './shader/BindResource';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the WebGPU bind groups. this is how data is bound to a shader when rendering\n * @category rendering\n * @advanced\n */\nexport class BindGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'bindGroup',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _hash: Record<string, GPUBindGroup> = Object.create(null);\n    private _gpu: GPU;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_hash');\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getBindGroup(bindGroup: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        bindGroup._updateKey();\n\n        const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n\n        return gpuBindGroup;\n    }\n\n    private _createBindGroup(group: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        const device = this._gpu.device;\n        const groupLayout = program.layout[groupIndex];\n        const entries: GPUBindGroupEntry[] = [];\n        const renderer = this._renderer;\n\n        for (const j in groupLayout)\n        {\n            const resource: BindResource = group.resources[j] ?? group.resources[groupLayout[j]];\n            let gpuResource: GPUSampler | GPUTextureView | GPUExternalTexture | GPUBufferBinding;\n            // TODO make this dynamic..\n\n            if (resource._resourceType === 'uniformGroup')\n            {\n                const uniformGroup = resource as UniformGroup;\n\n                renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n\n                const buffer = uniformGroup.buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'buffer')\n            {\n                const buffer = resource as Buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'bufferResource')\n            {\n                const bufferResource = resource as BufferResource;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n                    offset: bufferResource.offset,\n                    size: bufferResource.size,\n                };\n            }\n            else if (resource._resourceType === 'textureSampler')\n            {\n                const sampler = resource as TextureStyle;\n\n                gpuResource = renderer.texture.getGpuSampler(sampler);\n            }\n            else if (resource._resourceType === 'textureSource')\n            {\n                const texture = resource as TextureSource;\n\n                gpuResource = renderer.texture.getGpuSource(texture).createView({\n\n                });\n            }\n\n            entries.push({\n                binding: groupLayout[j],\n                resource: gpuResource,\n            });\n        }\n\n        const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n\n        const gpuBindGroup = device.createBindGroup({\n            layout,\n            entries,\n        });\n\n        this._hash[group._key] = gpuBindGroup;\n\n        return gpuBindGroup;\n    }\n\n    public destroy(): void\n    {\n        for (const key of Object.keys(this._hash))\n        {\n            this._hash[key] = null;\n        }\n\n        this._hash = null;\n\n        (this._renderer as null) = null;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/**\n * System plugin to the renderer to manage buffers.\n * @category rendering\n * @advanced\n */\nexport class GpuBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    protected CONTEXT_UID: number;\n    private _gpuBuffers: { [key: number]: GPUBuffer } = Object.create(null);\n    private readonly _managedBuffers: Buffer[] = [];\n\n    private _gpu: GPU;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        renderer.renderableGC.addManagedHash(this, '_gpuBuffers');\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n    }\n\n    public updateBuffer(buffer: Buffer): GPUBuffer\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n\n        const data = buffer.data;\n\n        // TODO this can be better...\n        if (buffer._updateID && data)\n        {\n            buffer._updateID = 0;\n\n            // make sure\n            this._gpu.device.queue.writeBuffer(\n                gpuBuffer, 0, data.buffer, 0,\n                // round to the nearest 4 bytes\n                ((buffer._updateSize || data.byteLength) + 3) & ~3\n            );\n        }\n\n        return gpuBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        for (const id in this._gpuBuffers)\n        {\n            this._gpuBuffers[id].destroy();\n        }\n\n        this._gpuBuffers = {};\n    }\n\n    public createGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        if (!this._gpuBuffers[buffer.uid])\n        {\n            buffer.on('update', this.updateBuffer, this);\n            buffer.on('change', this.onBufferChange, this);\n            buffer.on('destroy', this.onBufferDestroy, this);\n\n            this._managedBuffers.push(buffer);\n        }\n\n        const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n\n        buffer._updateID = 0;\n\n        if (buffer.data)\n        {\n            // TODO if data is static, this can be mapped at creation\n            fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());\n\n            gpuBuffer.unmap();\n        }\n\n        this._gpuBuffers[buffer.uid] = gpuBuffer;\n\n        return gpuBuffer;\n    }\n\n    protected onBufferChange(buffer: Buffer)\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid];\n\n        gpuBuffer.destroy();\n        buffer._updateID = 0;\n        this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);\n    }\n\n    /**\n     * Disposes buffer\n     * @param buffer - buffer with data\n     */\n    protected onBufferDestroy(buffer: Buffer): void\n    {\n        this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);\n\n        this._destroyBuffer(buffer);\n    }\n\n    public destroy(): void\n    {\n        this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));\n\n        (this._managedBuffers as null) = null;\n\n        this._gpuBuffers = null;\n    }\n\n    private _destroyBuffer(buffer: Buffer): void\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid];\n\n        gpuBuffer.destroy();\n\n        buffer.off('update', this.updateBuffer, this);\n        buffer.off('change', this.onBufferChange, this);\n        buffer.off('destroy', this.onBufferDestroy, this);\n\n        this._gpuBuffers[buffer.uid] = null;\n    }\n}\n\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles color masking for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuColorMaskSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _colorMaskCache = 0b1111;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setMask(colorMask: number)\n    {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n\n        this._renderer.pipeline.setColorMask(colorMask);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._colorMaskCache = null;\n    }\n}\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { GpuPowerPreference } from '../types';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The GPU object.\n * Contains the GPU adapter and device.\n * @category rendering\n * @advanced\n */\nexport interface GPU\n{\n    /** The GPU adapter */\n    adapter: GPUAdapter;\n    /** The GPU device */\n    device: GPUDevice;\n}\n\n/**\n * Options for the WebGPU context.\n * @property {GpuPowerPreference} [powerPreference=default] - An optional hint indicating what configuration of GPU\n * is suitable for the WebGPU context, can be `'high-performance'` or `'low-power'`.\n * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n * while setting to `'low-power'` will prioritize power saving over rendering performance.\n * @property {boolean} [forceFallbackAdapter=false] - Force the use of the fallback adapter\n * @category rendering\n * @advanced\n */\nexport interface GpuContextOptions\n{\n    /**\n     * An optional hint indicating what configuration of GPU is suitable for the WebGPU context,\n     * can be `'high-performance'` or `'low-power'`.\n     * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n     * while setting to `'low-power'` will prioritize power saving over rendering performance.\n     * @default undefined\n     */\n    powerPreference?: GpuPowerPreference;\n    /**\n     * Force the use of the fallback adapter\n     * @default false\n     */\n    forceFallbackAdapter: boolean;\n    /** Using shared device and adaptor from other engine */\n    gpu?: GPU;\n}\n\n/**\n * System plugin to the renderer to manage the context.\n * @class\n * @category rendering\n * @advanced\n */\nexport class GpuDeviceSystem implements System<GpuContextOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'device',\n    } as const;\n\n    /** The default options for the GpuDeviceSystem. */\n    public static defaultOptions: GpuContextOptions = {\n        /**\n         * {@link WebGPUOptions.powerPreference}\n         * @default default\n         */\n        powerPreference: undefined,\n        /**\n         * Force the use of the fallback adapter\n         * @default false\n         */\n        forceFallbackAdapter: false,\n    };\n\n    /** The GPU device */\n    public gpu: GPU;\n\n    private _renderer: WebGPURenderer;\n    private _initPromise: Promise<void>;\n\n    /**\n     * @param {WebGPURenderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public async init(options: GpuContextOptions): Promise<void>\n    {\n        if (this._initPromise) return this._initPromise;\n\n        this._initPromise = (options.gpu ? Promise.resolve(options.gpu) : this._createDeviceAndAdaptor(options))\n            .then((gpu) =>\n            {\n                this.gpu = gpu;\n\n                this._renderer.runners.contextChange.emit(this.gpu);\n            });\n\n        return this._initPromise;\n    }\n\n    /**\n     * Handle the context change event\n     * @param gpu\n     */\n    protected contextChange(gpu: GPU): void\n    {\n        this._renderer.gpu = gpu;\n    }\n\n    /**\n     * Helper class to create a WebGL Context\n     * @param {object} options - An options object that gets passed in to the canvas element containing the\n     *    context attributes\n     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n     * @returns {WebGLRenderingContext} the WebGL context\n     */\n    private async _createDeviceAndAdaptor(options: GpuContextOptions): Promise<GPU>\n    {\n        // TODO we only need one of these..\n        const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({\n            powerPreference: options.powerPreference,\n            forceFallbackAdapter: options.forceFallbackAdapter,\n        });\n\n        const requiredFeatures = [\n            'texture-compression-bc',\n            'texture-compression-astc',\n            'texture-compression-etc2',\n        ].filter((feature) => adapter.features.has(feature)) as GPUFeatureName[];\n\n        // TODO and one of these!\n        const device = await adapter.requestDevice({\n            requiredFeatures\n        });\n\n        return { adapter, device };\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { GpuRenderTarget } from './renderTarget/GpuRenderTarget';\nimport type { GpuRenderTargetAdaptor } from './renderTarget/GpuRenderTargetAdaptor';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles encoding commands for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuEncoderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'encoder',\n        priority: 1\n    } as const;\n\n    public commandEncoder: GPUCommandEncoder;\n    public renderPassEncoder: GPURenderPassEncoder;\n    public commandFinished: Promise<void>;\n\n    private _resolveCommandFinished: (value: void) => void;\n\n    private _gpu: GPU;\n    private _boundBindGroup: Record<number, BindGroup> = Object.create(null);\n    private _boundVertexBuffer: Record<number, Buffer> = Object.create(null);\n    private _boundIndexBuffer: Buffer;\n    private _boundPipeline: GPURenderPipeline;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public renderStart(): void\n    {\n        this.commandFinished = new Promise((resolve) =>\n        {\n            this._resolveCommandFinished = resolve;\n        });\n\n        // generate a render pass description..\n        // create an encoder..\n        this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    }\n\n    public beginRenderPass(gpuRenderTarget: GpuRenderTarget)\n    {\n        this.endRenderPass();\n\n        this._clearCache();\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n    }\n\n    public endRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n        }\n\n        this.renderPassEncoder = null;\n    }\n\n    public setViewport(viewport: Rectangle): void\n    {\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    }\n\n    public setPipelineFromGeometryProgramAndState(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: any,\n        topology?: Topology,\n    ): void\n    {\n        const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n\n        this.setPipeline(pipeline);\n    }\n\n    public setPipeline(pipeline: GPURenderPipeline)\n    {\n        if (this._boundPipeline === pipeline) return;\n        this._boundPipeline = pipeline;\n\n        this.renderPassEncoder.setPipeline(pipeline);\n    }\n\n    private _setVertexBuffer(index: number, buffer: Buffer)\n    {\n        if (this._boundVertexBuffer[index] === buffer) return;\n\n        this._boundVertexBuffer[index] = buffer;\n\n        this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n    }\n\n    private _setIndexBuffer(buffer: Buffer)\n    {\n        if (this._boundIndexBuffer === buffer) return;\n\n        this._boundIndexBuffer = buffer;\n\n        const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? 'uint16' : 'uint32';\n\n        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n    }\n\n    public resetBindGroup(index: number)\n    {\n        this._boundBindGroup[index] = null;\n    }\n\n    public setBindGroup(index: number, bindGroup: BindGroup, program: GpuProgram)\n    {\n        if (this._boundBindGroup[index] === bindGroup) return;\n        this._boundBindGroup[index] = bindGroup;\n\n        bindGroup._touch(this._renderer.textureGC.count);\n\n        // TODO getting the bind group works as it looks at th e assets and generates a key\n        // should this just be hidden behind a dirty flag?\n        const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n\n        // mark each item as having been used..\n        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n    }\n\n    public setGeometry(geometry: Geometry, program: GpuProgram)\n    {\n        // when binding a buffers for geometry, there is no need to bind a buffer more than once if it is interleaved.\n        // which is often the case for Pixi. This is a performance optimisation.\n        // Instead of looping through the attributes, we instead call getBufferNamesToBind\n        // which returns a list of buffer names that need to be bound.\n        // we can then loop through this list and bind the buffers.\n        // essentially only binding a single time for any buffers that are interleaved.\n        const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);\n\n        for (const i in buffersToBind)\n        {\n            this._setVertexBuffer(parseInt(i, 10), geometry.attributes[buffersToBind[i]].buffer);\n        }\n\n        if (geometry.indexBuffer)\n        {\n            this._setIndexBuffer(geometry.indexBuffer);\n        }\n    }\n\n    private _setShaderBindGroups(shader: Shader, skipSync?: boolean)\n    {\n        for (const i in shader.groups)\n        {\n            const bindGroup = shader.groups[i] as BindGroup;\n\n            // update any uniforms?\n            if (!skipSync)\n            {\n                this._syncBindGroup(bindGroup);\n            }\n\n            this.setBindGroup(i as unknown as number, bindGroup, shader.gpuProgram);\n        }\n    }\n\n    private _syncBindGroup(bindGroup: BindGroup)\n    {\n        for (const j in bindGroup.resources)\n        {\n            const resource = bindGroup.resources[j];\n\n            if ((resource as UniformGroup).isUniformGroup)\n            {\n                this._renderer.ubo.updateUniformGroup(resource as UniformGroup);\n            }\n        }\n    }\n\n    public draw(options: {\n        geometry: Geometry;\n        shader: Shader;\n        state?: State;\n        topology?: Topology;\n        size?: number;\n        start?: number;\n        instanceCount?: number;\n        skipSync?: boolean;\n    })\n    {\n        const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n\n        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n        this.setGeometry(geometry, shader.gpuProgram);\n        this._setShaderBindGroups(shader, skipSync);\n\n        if (geometry.indexBuffer)\n        {\n            this.renderPassEncoder.drawIndexed(\n                size || geometry.indexBuffer.data.length,\n                instanceCount ?? geometry.instanceCount,\n                start || 0\n            );\n        }\n        else\n        {\n            this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);\n        }\n    }\n\n    public finishRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n            this.renderPassEncoder = null;\n        }\n    }\n\n    public postrender()\n    {\n        this.finishRenderPass();\n\n        this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n\n        this._resolveCommandFinished();\n\n        this.commandEncoder = null;\n    }\n\n    // restores a render pass if finishRenderPass was called\n    // not optimised as really used for debugging!\n    // used when we want to stop drawing and log a texture..\n    public restoreRenderPass()\n    {\n        const descriptor = (this._renderer.renderTarget.adaptor as GpuRenderTargetAdaptor).getDescriptor(\n            this._renderer.renderTarget.renderTarget,\n            false,\n            [0, 0, 0, 1],\n        );\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n\n        const boundPipeline = this._boundPipeline;\n        const boundVertexBuffer = { ...this._boundVertexBuffer };\n        const boundIndexBuffer = this._boundIndexBuffer;\n        const boundBindGroup = { ...this._boundBindGroup };\n\n        this._clearCache();\n\n        const viewport = this._renderer.renderTarget.viewport;\n\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n        // reinstate the cache...\n\n        this.setPipeline(boundPipeline);\n\n        for (const i in boundVertexBuffer)\n        {\n            this._setVertexBuffer(i as unknown as number, boundVertexBuffer[i]);\n        }\n\n        for (const i in boundBindGroup)\n        {\n            this.setBindGroup(i as unknown as number, boundBindGroup[i], null);\n        }\n\n        this._setIndexBuffer(boundIndexBuffer);\n    }\n\n    private _clearCache()\n    {\n        for (let i = 0; i < 16; i++)\n        {\n            this._boundBindGroup[i] = null;\n            this._boundVertexBuffer[i] = null;\n        }\n\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._gpu = null;\n        this._boundBindGroup = null;\n        this._boundVertexBuffer = null;\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { type System } from '../shared/system/System';\nimport { type WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The GpuLimitsSystem provides information about the capabilities and limitations of the underlying GPU.\n * These limits, such as the maximum number of textures that can be used in a shader\n * (`maxTextures`) or the maximum number of textures that can be batched together (`maxBatchableTextures`),\n * are determined by the specific graphics hardware and driver.\n *\n * The values for these limits are not available immediately upon instantiation of the class.\n * They are populated when the WebGPU Device rendering context is successfully initialized and ready,\n * which occurs after the `renderer.init()` method has completed.\n * Attempting to access these properties before the context is ready will result in undefined or default values.\n *\n * This system allows the renderer to adapt its behavior and resource allocation strategies\n * to stay within the supported boundaries of the GPU, ensuring optimal performance and stability.\n * @example\n * ```ts\n * const renderer = new WebGPURenderer();\n * await renderer.init(); // GPU limits are populated after this call\n *\n * console.log(renderer.limits.maxTextures);\n * console.log(renderer.limits.maxBatchableTextures);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GpuLimitsSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'limits',\n    } as const;\n\n    /** The maximum number of textures that can be used by a shader */\n    public maxTextures: number;\n    /** The maximum number of batchable textures */\n    public maxBatchableTextures: number;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public contextChange(): void\n    {\n        this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage;\n        this.maxBatchableTextures = this.maxTextures;\n    }\n\n    public destroy(): void\n    {\n        // boom!\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { STENCIL_MODES } from '../shared/state/const';\n\nimport type { RenderTarget } from '../shared/renderTarget/RenderTarget';\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @category rendering\n * @advanced\n */\nexport class GpuStencilSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'stencil',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _renderTargetStencilState: Record<number, {\n        stencilMode: STENCIL_MODES;\n        stencilReference: number;\n    }> = Object.create(null);\n\n    private _activeRenderTarget: RenderTarget;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n\n        if (!stencilState)\n        {\n            stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n                stencilMode: STENCIL_MODES.DISABLED,\n                stencilReference: 0,\n            };\n        }\n\n        this._activeRenderTarget = renderTarget;\n\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES, stencilReference: number)\n    {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n\n        const renderer = this._renderer;\n\n        renderer.pipeline.setStencilMode(stencilMode);\n        renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n    }\n\n    public destroy()\n    {\n        this._renderer.renderTarget.onRenderTargetChange.remove(this);\n\n        (this._renderer as null) = null;\n\n        this._activeRenderTarget = null;\n        this._renderTargetStencilState = null;\n    }\n}\n","import type { UboElement, UboLayout, UNIFORM_TYPES, UniformData } from '../../../shared/shader/types';\n\n/** @internal */\nexport const WGSL_ALIGN_SIZE_DATA: Record<UNIFORM_TYPES | string, {align: number, size: number}> = {\n    i32: { align: 4, size: 4 },\n    u32: { align: 4, size: 4 },\n    f32: { align: 4, size: 4 },\n    f16: { align: 2, size: 2 },\n    'vec2<i32>': { align: 8, size: 8 },\n    'vec2<u32>': { align: 8, size: 8 },\n    'vec2<f32>': { align: 8, size: 8 },\n    'vec2<f16>': { align: 4, size: 4 },\n    'vec3<i32>': { align: 16, size: 12 },\n    'vec3<u32>': { align: 16, size: 12 },\n    'vec3<f32>': { align: 16, size: 12 },\n    'vec3<f16>': { align: 8, size: 6 },\n    'vec4<i32>': { align: 16, size: 16 },\n    'vec4<u32>': { align: 16, size: 16 },\n    'vec4<f32>': { align: 16, size: 16 },\n    'vec4<f16>': { align: 8, size: 8 },\n    'mat2x2<f32>': { align: 8, size: 16 },\n    'mat2x2<f16>': { align: 4, size: 8 },\n    'mat3x2<f32>': { align: 8, size: 24 },\n    'mat3x2<f16>': { align: 4, size: 12 },\n    'mat4x2<f32>': { align: 8, size: 32 },\n    'mat4x2<f16>': { align: 4, size: 16 },\n    'mat2x3<f32>': { align: 16, size: 32 },\n    'mat2x3<f16>': { align: 8, size: 16 },\n    'mat3x3<f32>': { align: 16, size: 48 },\n    'mat3x3<f16>': { align: 8, size: 24 },\n    'mat4x3<f32>': { align: 16, size: 64 },\n    'mat4x3<f16>': { align: 8, size: 32 },\n    'mat2x4<f32>': { align: 16, size: 32 },\n    'mat2x4<f16>': { align: 8, size: 16 },\n    'mat3x4<f32>': { align: 16, size: 48 },\n    'mat3x4<f16>': { align: 8, size: 24 },\n    'mat4x4<f32>': { align: 16, size: 64 },\n    'mat4x4<f16>': { align: 8, size: 32 },\n};\n\n/**\n * @param uniformData\n * @internal\n */\nexport function createUboElementsWGSL(uniformData: UniformData[]): UboLayout\n{\n    const uboElements: UboElement[] = uniformData.map((data: UniformData) =>\n        ({\n            data,\n            offset: 0,\n            size: 0,\n        }));\n\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n        const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n\n        if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type])\n        {\n            throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n        }\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, align) * uboElement.data.size;\n        }\n\n        offset = Math.ceil((offset) / align) * align;\n\n        // TODO deal with Arrays\n        uboElement.size = size;\n\n        uboElement.offset = offset;\n\n        offset += size;\n    }\n\n    // must align to 16 bits!\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\n","import { WGSL_ALIGN_SIZE_DATA } from './createUboElementsWGSL';\n\nimport type { UboElement } from '../../../shared/shader/types';\n\n/**\n * This generates a function that will sync an array to the uniform buffer\n * following the wgsl layout\n * @param uboElement - the element to generate the array sync for\n * @param offsetToAdd - the offset to append at the start of the code\n * @returns - the generated code\n * @internal\n */\nexport function generateArraySyncWGSL(uboElement: UboElement, offsetToAdd: number): string\n{\n    // this is in byte..\n    const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n\n    const remainder = (align - size) / 4;\n    const data = uboElement.data.type.indexOf('i32') >= 0 ? 'dataInt32' : 'data';\n\n    return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ''}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 ${data}[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ''}\n         }\n     `;\n}\n","import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction';\nimport { uboSyncFunctionsWGSL } from '../../../shared/shader/utils/uboSyncFunctions';\nimport { generateArraySyncWGSL } from './generateArraySyncWGSL';\n\nimport type { UboElement, UniformsSyncCallback } from '../../../shared/shader/types';\n\n/**\n * @param uboElements\n * @internal\n */\nexport function createUboSyncFunctionWGSL(\n    uboElements: UboElement[],\n): UniformsSyncCallback\n{\n    return createUboSyncFunction(\n        uboElements,\n        'uboWgsl',\n        generateArraySyncWGSL,\n        uboSyncFunctionsWGSL,\n    );\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { UboSystem } from '../shared/shader/UboSystem';\nimport { createUboElementsWGSL } from './shader/utils/createUboElementsWGSL';\nimport { createUboSyncFunctionWGSL } from './shader/utils/createUboSyncFunctionWGSL';\n\n/**\n * System plugin to the renderer to manage uniform buffers. With a WGSL twist!\n * @category rendering\n * @advanced\n */\nexport class GpuUboSystem extends UboSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'ubo',\n    } as const;\n\n    constructor()\n    {\n        super({\n            createUboElements: createUboElementsWGSL,\n            generateUboSync: createUboSyncFunctionWGSL,\n        });\n    }\n}\n","/** @internal */\nexport class UboBatch\n{\n    public data: Float32Array;\n    private readonly _minUniformOffsetAlignment: number = 256;\n\n    public byteIndex = 0;\n\n    constructor({ minUniformOffsetAlignment }: {minUniformOffsetAlignment: number})\n    {\n        this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n        this.data = new Float32Array(65535);\n    }\n\n    public clear(): void\n    {\n        this.byteIndex = 0;\n    }\n\n    public addEmptyGroup(size: number): number\n    {\n        // update the buffer.. only float32 for now!\n        if (size > this._minUniformOffsetAlignment / 4)\n        {\n            throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n        }\n\n        const start = this.byteIndex;\n\n        let newSize = start + (size * 4);\n\n        newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n\n        if (newSize > this.data.length * 4)\n        {\n            // TODO push a new buffer\n            throw new Error('UniformBufferBatch: ubo batch got too big');\n        }\n\n        this.byteIndex = newSize;\n\n        return start;\n    }\n\n    public addGroup(array: Float32Array): number\n    {\n        const offset = this.addEmptyGroup(array.length);\n\n        for (let i = 0; i < array.length; i++)\n        {\n            this.data[(offset / 4) + i] = array[i];\n        }\n\n        return offset;\n    }\n\n    public destroy()\n    {\n        this.data = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Buffer } from '../shared/buffer/Buffer';\nimport { BufferResource } from '../shared/buffer/BufferResource';\nimport { BufferUsage } from '../shared/buffer/const';\nimport { UboBatch } from './buffer/UboBatch';\nimport { BindGroup } from './shader/BindGroup';\n\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\nconst minUniformOffsetAlignment = 128;// 256 / 2;\n\n/** @internal */\nexport class GpuUniformBatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'uniformBatch',\n    } as const;\n\n    private _renderer: WebGPURenderer;\n\n    private _bindGroupHash: Record<number, BindGroup> = Object.create(null);\n    private readonly _batchBuffer: UboBatch;\n\n    // number of buffers..\n    private _buffers: Buffer[] = [];\n\n    private _bindGroups: BindGroup[] = [];\n    private _bufferResources: BufferResource[] = [];\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_bindGroupHash');\n\n        this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n\n        const totalBuffers = (256 / minUniformOffsetAlignment);\n\n        for (let i = 0; i < totalBuffers; i++)\n        {\n            let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n\n            if (i === 0) usage |= BufferUsage.COPY_SRC;\n\n            this._buffers.push(new Buffer({\n                data: this._batchBuffer.data,\n                usage\n            }));\n        }\n    }\n\n    public renderEnd()\n    {\n        this._uploadBindGroups();\n        this._resetBindGroups();\n    }\n\n    private _resetBindGroups()\n    {\n        for (const i in this._bindGroupHash)\n        {\n            this._bindGroupHash[i] = null;\n        }\n\n        this._batchBuffer.clear();\n    }\n\n    // just works for single bind groups for now\n    public getUniformBindGroup(group: UniformGroup<any>, duplicate: boolean): BindGroup\n    {\n        if (!duplicate && this._bindGroupHash[group.uid])\n        {\n            return this._bindGroupHash[group.uid];\n        }\n\n        this._renderer.ubo.ensureUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addEmptyGroup(data.length);\n\n        this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n\n        this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n\n        return this._bindGroupHash[group.uid];\n    }\n\n    public getUboResource(group: UniformGroup<any>): BufferResource\n    {\n        this._renderer.ubo.updateUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBufferResource(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBindGroup(data: Float32Array): BindGroup\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBindGroup(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBufferResource(data: Float32Array): BufferResource\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        const index = offset / minUniformOffsetAlignment;\n\n        return this._getBufferResource(index);\n    }\n\n    private _getBufferResource(index: number): BufferResource\n    {\n        if (!this._bufferResources[index])\n        {\n            const buffer = this._buffers[index % 2];\n\n            this._bufferResources[index] = new BufferResource({\n                buffer,\n                offset: ((index / 2) | 0) * 256,\n                size: minUniformOffsetAlignment\n            });\n        }\n\n        return this._bufferResources[index];\n    }\n\n    private _getBindGroup(index: number): BindGroup\n    {\n        if (!this._bindGroups[index])\n        {\n            // even!\n            const bindGroup = new BindGroup({\n                0: this._getBufferResource(index),\n            });\n\n            this._bindGroups[index] = bindGroup;\n        }\n\n        return this._bindGroups[index];\n    }\n\n    private _uploadBindGroups()\n    {\n        const bufferSystem = this._renderer.buffer;\n\n        const firstBuffer = this._buffers[0];\n\n        firstBuffer.update(this._batchBuffer.byteIndex);\n\n        bufferSystem.updateBuffer(firstBuffer);\n\n        const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n\n        for (let i = 1; i < this._buffers.length; i++)\n        {\n            const buffer = this._buffers[i];\n\n            commandEncoder.copyBufferToBuffer(\n                bufferSystem.getGPUBuffer(firstBuffer),\n                minUniformOffsetAlignment,\n                bufferSystem.getGPUBuffer(buffer),\n                0,\n                this._batchBuffer.byteIndex\n            );\n        }\n\n        // TODO make a system that will que up all commands in to one array?\n        this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this._bindGroups.length; i++)\n        {\n            this._bindGroups[i]?.destroy();\n        }\n\n        this._bindGroups = null;\n        this._bindGroupHash = null;\n\n        for (let i = 0; i < this._buffers.length; i++)\n        {\n            this._buffers[i].destroy();\n        }\n        this._buffers = null;\n\n        for (let i = 0; i < this._bufferResources.length; i++)\n        {\n            this._bufferResources[i].destroy();\n        }\n\n        this._bufferResources = null;\n\n        this._batchBuffer.destroy();\n        this._bindGroupHash = null;\n\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes';\nimport { STENCIL_MODES } from '../../shared/state/const';\nimport { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { State } from '../../shared/state/State';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuRenderTarget } from '../renderTarget/GpuRenderTarget';\nimport type { GpuProgram } from '../shader/GpuProgram';\nimport type { StencilState } from '../state/GpuStencilModesToPixi';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\nconst topologyStringToId = {\n    'point-list': 0,\n    'line-list': 1,\n    'line-strip': 2,\n    'triangle-list': 3,\n    'triangle-strip': 4,\n};\n\n// geometryLayouts = 256; // 8 bits // 256 states // value 0-255;\n// shaderKeys = 256; // 8 bits // 256 states // value 0-255;\n// state = 64; // 6 bits // 64 states // value 0-63;\n// blendMode = 32; // 5 bits // 32 states // value 0-31;\n// topology = 8; // 3 bits // 8 states // value 0-7;\nfunction getGraphicsStateKey(\n    geometryLayout: number,\n    shaderKey: number,\n    state: number,\n    blendMode: number,\n    topology: number,\n): number\n{\n    return (geometryLayout << 24) // Allocate the 8 bits for geometryLayouts at the top\n         | (shaderKey << 16) // Next 8 bits for shaderKeys\n         | (state << 10) // 6 bits for state\n         | (blendMode << 5) // 5 bits for blendMode\n         | topology; // And 3 bits for topology at the least significant position\n}\n\n// colorMask = 16;// 4 bits // 16 states // value 0-15;\n// stencilState = 8; // 3 bits // 8 states // value 0-7;\n// renderTarget = 1; // 2 bit // 3 states // value 0-3; // none, stencil, depth, depth-stencil\n// multiSampleCount = 1; // 1 bit // 2 states // value 0-1;\nfunction getGlobalStateKey(\n    stencilStateId: number,\n    multiSampleCount: number,\n    colorMask: number,\n    renderTarget: number,\n): number\n{\n    return (colorMask << 6) // Allocate the 4 bits for colorMask at the top\n         | (stencilStateId << 3) // Next 3 bits for stencilStateId\n         | (renderTarget << 1) // 2 bits for renderTarget\n         | multiSampleCount; // And 1 bit for multiSampleCount at the least significant position\n}\n\ntype PipeHash = Record<number, GPURenderPipeline>;\n\n/**\n * A system that creates and manages the GPU pipelines.\n *\n * Caching Mechanism: At its core, the system employs a two-tiered caching strategy to minimize\n * the redundant creation of GPU pipelines (or \"pipes\"). This strategy is based on generating unique\n * keys that represent the state of the graphics settings and the specific requirements of the\n * item being rendered. By caching these pipelines, subsequent draw calls with identical configurations\n * can reuse existing pipelines instead of generating new ones.\n *\n * State Management: The system differentiates between \"global\" state properties (like color masks\n * and stencil masks, which do not change frequently) and properties that may vary between draw calls\n * (such as geometry, shaders, and blend modes). Unique keys are generated for both these categories\n * using getStateKey for global state and getGraphicsStateKey for draw-specific settings. These keys are\n * then then used to caching the pipe. The next time we need a pipe we can check\n * the cache by first looking at the state cache and then the pipe cache.\n * @category rendering\n * @advanced\n */\nexport class PipelineSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'pipeline',\n    } as const;\n    private readonly _renderer: WebGPURenderer;\n\n    protected CONTEXT_UID: number;\n\n    private _moduleCache: Record<string, GPUShaderModule> = Object.create(null);\n    private _bufferLayoutsCache: Record<number, GPUVertexBufferLayout[]> = Object.create(null);\n    private readonly _bindingNamesCache: Record<string, Record<string, string>> = Object.create(null);\n\n    private _pipeCache: PipeHash = Object.create(null);\n    private readonly _pipeStateCaches: Record<number, PipeHash> = Object.create(null);\n\n    private _gpu: GPU;\n    private _stencilState: StencilState;\n\n    private _stencilMode: STENCIL_MODES;\n    private _colorMask = 0b1111;\n    private _multisampleCount = 1;\n    private _depthStencilAttachment: 0 | 1;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n        this.setStencilMode(STENCIL_MODES.DISABLED);\n\n        this._updatePipeHash();\n    }\n\n    public setMultisampleCount(multisampleCount: number): void\n    {\n        if (this._multisampleCount === multisampleCount) return;\n\n        this._multisampleCount = multisampleCount;\n\n        this._updatePipeHash();\n    }\n\n    public setRenderTarget(renderTarget: GpuRenderTarget)\n    {\n        this._multisampleCount = renderTarget.msaaSamples;\n        this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n\n        this._updatePipeHash();\n    }\n\n    public setColorMask(colorMask: number): void\n    {\n        if (this._colorMask === colorMask) return;\n\n        this._colorMask = colorMask;\n\n        this._updatePipeHash();\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES): void\n    {\n        if (this._stencilMode === stencilMode) return;\n\n        this._stencilMode = stencilMode;\n        this._stencilState = GpuStencilModesToPixi[stencilMode];\n\n        this._updatePipeHash();\n    }\n\n    public setPipeline(geometry: Geometry, program: GpuProgram, state: State, passEncoder: GPURenderPassEncoder): void\n    {\n        const pipeline = this.getPipeline(geometry, program, state);\n\n        passEncoder.setPipeline(pipeline);\n    }\n\n    public getPipeline(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: State,\n        topology?: Topology,\n    ): GPURenderPipeline\n    {\n        if (!geometry._layoutKey)\n        {\n            ensureAttributes(geometry, program.attributeData);\n\n            // prepare the geometry for the pipeline\n            this._generateBufferKey(geometry);\n        }\n\n        topology ||= geometry.topology;\n\n        // now we have set the Ids - the key is different...\n        const key = getGraphicsStateKey(\n            geometry._layoutKey,\n            program._layoutKey,\n            state.data,\n            state._blendModeId,\n            topologyStringToId[topology],\n        );\n\n        if (this._pipeCache[key]) return this._pipeCache[key];\n\n        this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n\n        return this._pipeCache[key];\n    }\n\n    private _createPipeline(geometry: Geometry, program: GpuProgram, state: State, topology: Topology): GPURenderPipeline\n    {\n        const device = this._gpu.device;\n\n        const buffers = this._createVertexBufferLayouts(geometry, program);\n\n        const blendModes = this._renderer.state.getColorTargets(state);\n\n        blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n\n        const layout = this._renderer.shader.getProgramData(program).pipeline;\n\n        const descriptor: GPURenderPipelineDescriptor = {\n            // TODO later check if its helpful to create..\n            // layout,\n            vertex: {\n                module: this._getModule(program.vertex.source),\n                entryPoint: program.vertex.entryPoint,\n                // geometry..\n                buffers,\n            },\n            fragment: {\n                module: this._getModule(program.fragment.source),\n                entryPoint: program.fragment.entryPoint,\n                targets: blendModes,\n            },\n            primitive: {\n                topology,\n                cullMode: state.cullMode,\n            },\n            layout,\n            multisample: {\n                count: this._multisampleCount,\n            },\n            // depthStencil,\n            label: `PIXI Pipeline`,\n        };\n\n        // only apply if the texture has stencil or depth\n        if (this._depthStencilAttachment)\n        {\n            // mask states..\n            descriptor.depthStencil = {\n                ...this._stencilState,\n                format: 'depth24plus-stencil8',\n                depthWriteEnabled: state.depthTest,\n                depthCompare: state.depthTest ? 'less' : 'always',\n            };\n        }\n\n        const pipeline = device.createRenderPipeline(descriptor);\n\n        return pipeline;\n    }\n\n    private _getModule(code: string): GPUShaderModule\n    {\n        return this._moduleCache[code] || this._createModule(code);\n    }\n\n    private _createModule(code: string): GPUShaderModule\n    {\n        const device = this._gpu.device;\n\n        this._moduleCache[code] = device.createShaderModule({\n            code,\n        });\n\n        return this._moduleCache[code];\n    }\n\n    private _generateBufferKey(geometry: Geometry): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(geometry.attributes).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = geometry.attributes[attributeKeys[i]];\n\n            keyGen[index++] = attribute.offset;\n            keyGen[index++] = attribute.format;\n            keyGen[index++] = attribute.stride;\n            keyGen[index++] = attribute.instance;\n        }\n\n        const stringKey = keyGen.join('|');\n\n        geometry._layoutKey = createIdFromString(stringKey, 'geometry');\n\n        return geometry._layoutKey;\n    }\n\n    private _generateAttributeLocationsKey(program: GpuProgram): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(program.attributeData).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = program.attributeData[attributeKeys[i]];\n\n            keyGen[index++] = attribute.location;\n        }\n\n        const stringKey = keyGen.join('|');\n\n        program._attributeLocationsKey = createIdFromString(stringKey, 'programAttributes');\n\n        return program._attributeLocationsKey;\n    }\n\n    /**\n     * Returns a hash of buffer names mapped to bind locations.\n     * This is used to bind the correct buffer to the correct location in the shader.\n     * @param geometry - The geometry where to get the buffer names\n     * @param program - The program where to get the buffer names\n     * @returns An object of buffer names mapped to the bind location.\n     */\n    public getBufferNamesToBind(geometry: Geometry, program: GpuProgram): Record<string, string>\n    {\n        const key = (geometry._layoutKey << 16) | program._attributeLocationsKey;\n\n        if (this._bindingNamesCache[key]) return this._bindingNamesCache[key];\n\n        const data = this._createVertexBufferLayouts(geometry, program);\n\n        // now map the data to the buffers..\n        const bufferNamesToBind: Record<string, string> = Object.create(null);\n\n        const attributeData = program.attributeData;\n\n        for (let i = 0; i < data.length; i++)\n        {\n            const attributes = Object.values(data[i].attributes);\n\n            const shaderLocation = attributes[0].shaderLocation;\n\n            for (const j in attributeData)\n            {\n                if (attributeData[j].location === shaderLocation)\n                {\n                    bufferNamesToBind[i] = j;\n                    break;\n                }\n            }\n        }\n\n        this._bindingNamesCache[key] = bufferNamesToBind;\n\n        return bufferNamesToBind;\n    }\n\n    private _createVertexBufferLayouts(geometry: Geometry, program: GpuProgram): GPUVertexBufferLayout[]\n    {\n        if (!program._attributeLocationsKey) this._generateAttributeLocationsKey(program);\n\n        const key = (geometry._layoutKey << 16) | program._attributeLocationsKey;\n\n        if (this._bufferLayoutsCache[key])\n        {\n            return this._bufferLayoutsCache[key];\n        }\n\n        const vertexBuffersLayout: GPUVertexBufferLayout[] = [];\n\n        geometry.buffers.forEach((buffer) =>\n        {\n            const bufferEntry: GPUVertexBufferLayout = {\n                arrayStride: 0,\n                stepMode: 'vertex',\n                attributes: [],\n            };\n\n            const bufferEntryAttributes = bufferEntry.attributes as GPUVertexAttribute[];\n\n            for (const i in program.attributeData)\n            {\n                const attribute = geometry.attributes[i];\n\n                if ((attribute.divisor ?? 1) !== 1)\n                {\n                    // TODO: Maybe emulate divisor with storage_buffers/float_textures?\n                    // For now just issue a warning\n                    warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. `\n                        + 'WebGPU only supports a divisor value of 1');\n                }\n\n                if (attribute.buffer === buffer)\n                {\n                    bufferEntry.arrayStride = attribute.stride;\n                    bufferEntry.stepMode = attribute.instance ? 'instance' : 'vertex';\n\n                    bufferEntryAttributes.push({\n                        shaderLocation: program.attributeData[i].location,\n                        offset: attribute.offset,\n                        format: attribute.format,\n                    });\n                }\n            }\n\n            if (bufferEntryAttributes.length)\n            {\n                vertexBuffersLayout.push(bufferEntry);\n            }\n        });\n\n        this._bufferLayoutsCache[key] = vertexBuffersLayout;\n\n        return vertexBuffersLayout;\n    }\n\n    private _updatePipeHash(): void\n    {\n        const key = getGlobalStateKey(\n            this._stencilMode,\n            this._multisampleCount,\n            this._colorMask,\n            this._depthStencilAttachment\n        );\n\n        if (!this._pipeStateCaches[key])\n        {\n            this._pipeStateCaches[key] = Object.create(null);\n        }\n\n        this._pipeCache = this._pipeStateCaches[key];\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n        this._bufferLayoutsCache = null;\n    }\n}\n","import type { TextureSource } from '../../shared/texture/sources/TextureSource';\n\n/**\n * A class which holds the canvas contexts and textures for a render target.\n * @category rendering\n * @ignore\n */\nexport class GpuRenderTarget\n{\n    public contexts: GPUCanvasContext[] = [];\n    public msaaTextures: TextureSource[] = [];\n    public msaa: boolean;\n    public msaaSamples = 1;\n    public width: number;\n    public height: number;\n    public descriptor: GPURenderPassDescriptor;\n}\n","import { CLEAR } from '../../gl/const';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport { GpuRenderTarget } from './GpuRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/**\n * The WebGPU adaptor for the render target system. Allows the Render Target System to\n * be used with the WebGPU renderer\n * @category rendering\n * @ignore\n */\nexport class GpuRenderTargetAdaptor implements RenderTargetAdaptor<GpuRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GpuRenderTarget>;\n    private _renderer: WebGPURenderer<HTMLCanvasElement>;\n\n    public init(renderer: WebGPURenderer, renderTargetSystem: RenderTargetSystem<GpuRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderer = this._renderer;\n\n        const baseGpuTexture = this._getGpuColorTexture(\n            sourceRenderSurfaceTexture\n        );\n\n        const backGpuTexture = renderer.texture.getGpuSource(\n            destinationTexture.source\n        );\n\n        renderer.encoder.commandEncoder.copyTextureToTexture(\n            {\n                texture: baseGpuTexture,\n                origin: originSrc,\n            },\n            {\n                texture: backGpuTexture,\n                origin: originDest,\n            },\n            size\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n        gpuRenderTarget.descriptor = descriptor;\n\n        // TODO we should not finish a render pass each time we bind\n        // for example filters - we would want to push / pop render targets\n        this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n        this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n        this._renderer.encoder.setViewport(viewport);\n    }\n\n    public finishRenderPass()\n    {\n        this._renderer.encoder.endRenderPass();\n    }\n\n    /**\n     * returns the gpu texture for the first color texture in the render target\n     * mainly used by the filter manager to get copy the texture for blending\n     * @param renderTarget\n     * @returns a gpu texture\n     */\n    private _getGpuColorTexture(renderTarget: RenderTarget): GPUTexture\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (gpuRenderTarget.contexts[0])\n        {\n            return gpuRenderTarget.contexts[0].getCurrentTexture();\n        }\n\n        return this._renderer.texture.getGpuSource(\n            renderTarget.colorTextures[0].source\n        );\n    }\n\n    public getDescriptor(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL,\n        clearValue: RgbaArray\n    ): GPURenderPassDescriptor\n    {\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const colorAttachments = renderTarget.colorTextures.map(\n            (texture, i) =>\n            {\n                const context = gpuRenderTarget.contexts[i];\n\n                let view: GPUTextureView;\n                let resolveTarget: GPUTextureView;\n\n                if (context)\n                {\n                    const currentTexture = context.getCurrentTexture();\n\n                    const canvasTextureView = currentTexture.createView();\n\n                    view = canvasTextureView;\n                }\n                else\n                {\n                    view = this._renderer.texture.getGpuSource(texture).createView({\n                        mipLevelCount: 1,\n                    });\n                }\n\n                if (gpuRenderTarget.msaaTextures[i])\n                {\n                    resolveTarget = view;\n                    view = this._renderer.texture.getTextureView(\n                        gpuRenderTarget.msaaTextures[i]\n                    );\n                }\n\n                const loadOp = ((clear as CLEAR) & CLEAR.COLOR ? 'clear' : 'load') as GPULoadOp;\n\n                clearValue ??= renderTargetSystem.defaultClearColor;\n\n                return {\n                    view,\n                    resolveTarget,\n                    clearValue,\n                    storeOp: 'store',\n                    loadOp\n                };\n            }\n        ) as GPURenderPassColorAttachment[];\n\n        let depthStencilAttachment: GPURenderPassDepthStencilAttachment;\n\n        // if we have a depth or stencil buffer, we need to ensure we have a texture for it\n        // this is WebGPU specific - as WebGL does not require textures to run a depth / stencil buffer\n        if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture)\n        {\n            renderTarget.ensureDepthStencilTexture();\n            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n        }\n\n        if (renderTarget.depthStencilTexture)\n        {\n            const stencilLoadOp = (clear & CLEAR.STENCIL ? 'clear' : 'load') as GPULoadOp;\n            const depthLoadOp = (clear & CLEAR.DEPTH ? 'clear' : 'load') as GPULoadOp;\n\n            depthStencilAttachment = {\n                view: this._renderer.texture\n                    .getGpuSource(renderTarget.depthStencilTexture.source)\n                    .createView(),\n                stencilStoreOp: 'store',\n                stencilLoadOp,\n                depthClearValue: 1.0,\n                depthLoadOp,\n                depthStoreOp: 'store',\n            };\n        }\n\n        const descriptor: GPURenderPassDescriptor = {\n            colorAttachments,\n            depthStencilAttachment,\n        };\n\n        return descriptor;\n    }\n\n    public clear(renderTarget: RenderTarget, clear: CLEAR_OR_BOOL = true, clearColor?: RgbaArray, viewport?: Rectangle)\n    {\n        if (!clear) return;\n\n        const { gpu, encoder } = this._renderer;\n\n        const device = gpu.device;\n\n        const standAlone = encoder.commandEncoder === null;\n\n        if (standAlone)\n        {\n            const commandEncoder = device.createCommandEncoder();\n            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n\n            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n            passEncoder.end();\n\n            const gpuCommands = commandEncoder.finish();\n\n            device.queue.submit([gpuCommands]);\n        }\n        else\n        {\n            this.startRenderPass(renderTarget, clear, clearColor, viewport);\n        }\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GpuRenderTarget\n    {\n        // always true for WebGPU\n        renderTarget.isRoot = true;\n\n        const gpuRenderTarget = new GpuRenderTarget();\n\n        // create a context...\n        // is a canvas...\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (colorTexture instanceof CanvasSource)\n            {\n                const context = colorTexture.resource.getContext(\n                    'webgpu'\n                ) as unknown as GPUCanvasContext;\n\n                const alphaMode = (colorTexture as CanvasSource).transparent ? 'premultiplied' : 'opaque';\n\n                try\n                {\n                    context.configure({\n                        device: this._renderer.gpu.device,\n                        usage: GPUTextureUsage.TEXTURE_BINDING\n                            | GPUTextureUsage.COPY_DST\n                            | GPUTextureUsage.RENDER_ATTACHMENT\n                            | GPUTextureUsage.COPY_SRC,\n                        format: 'bgra8unorm',\n                        alphaMode,\n                    });\n                }\n                catch (e)\n                {\n                    console.error(e);\n                }\n\n                gpuRenderTarget.contexts[i] = context;\n            }\n\n            gpuRenderTarget.msaa = colorTexture.source.antialias;\n\n            if (colorTexture.source.antialias)\n            {\n                const msaaTexture = new TextureSource({\n                    width: 0,\n                    height: 0,\n                    sampleCount: 4,\n                });\n\n                gpuRenderTarget.msaaTextures[i] = msaaTexture;\n            }\n        });\n\n        if (gpuRenderTarget.msaa)\n        {\n            gpuRenderTarget.msaaSamples = 4;\n\n            if (renderTarget.depthStencilTexture)\n            {\n                renderTarget.depthStencilTexture.source.sampleCount = 4;\n            }\n        }\n\n        return gpuRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GpuRenderTarget)\n    {\n        gpuRenderTarget.contexts.forEach((context) =>\n        {\n            context.unconfigure();\n        });\n\n        gpuRenderTarget.msaaTextures.forEach((texture) =>\n        {\n            texture.destroy();\n        });\n\n        gpuRenderTarget.msaaTextures.length = 0;\n        gpuRenderTarget.contexts.length = 0;\n    }\n\n    public ensureDepthStencilTexture(renderTarget: RenderTarget)\n    {\n        // TODO This function will be more useful once we cache the descriptors\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa)\n        {\n            renderTarget.depthStencilTexture.source.sampleCount = 4;\n        }\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        gpuRenderTarget.width = renderTarget.width;\n        gpuRenderTarget.height = renderTarget.height;\n\n        if (gpuRenderTarget.msaa)\n        {\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const msaaTexture = gpuRenderTarget.msaaTextures[i];\n\n                msaaTexture?.resize(\n                    colorTexture.source.width,\n                    colorTexture.source.height,\n                    colorTexture.source._resolution\n                );\n            });\n        }\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport { GpuRenderTargetAdaptor } from './GpuRenderTargetAdaptor';\n\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuRenderTarget } from './GpuRenderTarget';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @category rendering\n * @advanced\n */\nexport class GpuRenderTargetSystem extends RenderTargetSystem<GpuRenderTarget>\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'renderTarget',\n    } as const;\n\n    public adaptor = new GpuRenderTargetAdaptor();\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer);\n\n        this.adaptor.init(renderer, this);\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuProgram } from './GpuProgram';\n\n/**\n * Data structure for GPU program layout.\n * Contains bind group layouts and pipeline layout.\n * @category rendering\n * @advanced\n */\nexport interface GPUProgramData\n{\n    bindGroups: GPUBindGroupLayout[]\n    pipeline: GPUPipelineLayout\n}\n\n/**\n * A system that manages the rendering of GpuPrograms.\n * @category rendering\n * @advanced\n */\nexport class GpuShaderSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    private _gpu: GPU;\n\n    private readonly _gpuProgramData: Record<number, GPUProgramData> = Object.create(null);\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getProgramData(program: GpuProgram)\n    {\n        return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n    }\n\n    private _createGPUProgramData(program: GpuProgram)\n    {\n        const device = this._gpu.device;\n\n        const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n\n        const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n\n        this._gpuProgramData[program._layoutKey] = {\n            bindGroups,\n            pipeline: device.createPipelineLayout(pipelineLayoutDesc),\n        };\n\n        // generally we avoid having to make this automatically\n        // keeping this for a reminder, if any issues popup\n        // program._gpuLayout = {\n        //     bindGroups: null,\n        //     pipeline: 'auto',\n        // };\n\n        return this._gpuProgramData[program._layoutKey];\n    }\n\n    public destroy(): void\n    {\n        // TODO destroy the _gpuProgramData\n        this._gpu = null;\n        (this._gpuProgramData as null) = null;\n    }\n}\n","import type { BLEND_MODES } from '../../shared/state/const';\n\n/** @internal */\nexport const GpuBlendModesToPixi: Partial<Record<BLEND_MODES, GPUBlendState>> = {};\n\nGpuBlendModesToPixi.normal = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.add = {\n    alpha: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.multiply = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'dst',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.screen = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.overlay = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.none = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'zero',\n        operation: 'add',\n    },\n};\n\n// not-premultiplied blend modes\nGpuBlendModesToPixi['normal-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['add-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['screen-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.erase = {\n    alpha: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.min = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'min',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'min',\n    },\n};\n\nGpuBlendModesToPixi.max = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'max',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'max',\n    },\n};\n\n// composite operations\n// GpuBlendModesToPixi[BLEND_MODES.SRC_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OVER] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.XOR] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// TODO - fix me\n// GLBlendModesToPixi[BLEND_MODES.SUBTRACT] = {\n//     alpha: {\n//         srcFactor: 'one',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { State } from '../../shared/state/State';\nimport { GpuBlendModesToPixi } from './GpuBlendModesToPixi';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\n\n/**\n * System plugin to the renderer to manage WebGL state machines.\n * @category rendering\n * @advanced\n */\nexport class GpuStateSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'state',\n    } as const;\n    /**\n     * State ID\n     * @readonly\n     */\n    public stateId: number;\n\n    /**\n     * Polygon offset\n     * @readonly\n     */\n    public polygonOffset: number;\n\n    /**\n     * Blend mode\n     * @default 'none'\n     * @readonly\n     */\n    public blendMode: BLEND_MODES;\n\n    /** Whether current blend equation is different */\n    protected _blendEq: boolean;\n\n    /**\n     * GL context\n     * @type {WebGLRenderingContext}\n     * @readonly\n     */\n    protected gpu: GPU;\n\n    /**\n     * Default WebGL State\n     * @readonly\n     */\n    protected defaultState: State;\n\n    constructor()\n    {\n        this.defaultState = new State();\n        this.defaultState.blend = true;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this.gpu = gpu;\n    }\n\n    /**\n     * Gets the blend mode data for the current state\n     * @param state - The state to get the blend mode from\n     */\n    public getColorTargets(state: State): GPUColorTargetState[]\n    {\n        const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n\n        return [\n            {\n                format: 'bgra8unorm',\n                writeMask: 0,\n                blend,\n            },\n        ];\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n    }\n}\n","import type { BufferImageSource } from '../../../shared/texture/sources/BufferImageSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadBufferImageResource = {\n\n    type: 'image',\n\n    upload(source: BufferImageSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        const resource = source.resource;\n\n        const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n\n        const bytesPerPixel = resource.byteLength / total;\n\n        gpu.device.queue.writeTexture(\n            { texture: gpuTexture },\n            resource,\n            {\n                offset: 0,\n                rowsPerImage: source.pixelHeight,\n                bytesPerRow: source.pixelHeight * bytesPerPixel,\n            },\n            {\n                width: source.pixelWidth,\n                height: source.pixelHeight,\n                depthOrArrayLayers: 1,\n            }\n        );\n    }\n} as GpuTextureUploader<BufferImageSource>;\n\n","import type { CompressedSource } from '../../../shared/texture/sources/CompressedSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const blockDataMap: Record<string, {blockBytes: number, blockWidth: number, blockHeight: number}> = {\n    'bc1-rgba-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'bc2-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc3-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc7-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'etc1-rgb-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'etc2-rgba8unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'astc-4x4-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n};\n\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\n/** @internal */\nexport const gpuUploadCompressedTextureResource = {\n\n    type: 'compressed',\n\n    upload(source: CompressedSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n\n        const blockData = blockDataMap[source.format] || defaultBlockData;\n\n        for (let i = 0; i < source.resource.length; i++)\n        {\n            const levelBuffer = source.resource[i];\n\n            const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n\n            gpu.device.queue.writeTexture(\n                {\n                    texture: gpuTexture,\n                    mipLevel: i\n                },\n                levelBuffer,\n                {\n                    offset: 0,\n                    bytesPerRow,\n                },\n                {\n                    width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n                    height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n                    depthOrArrayLayers: 1,\n                }\n            );\n\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n} as GpuTextureUploader<CompressedSource>;\n\n","import { DOMAdapter } from '../../../../../environment/adapter';\nimport { warn } from '../../../../../utils/logging/warn';\n\nimport type { TextureSource } from '../../../shared/texture/sources/TextureSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadImageResource = {\n\n    type: 'image',\n\n    upload(source: TextureSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        const resource = source.resource as ImageBitmap | HTMLCanvasElement | OffscreenCanvas | HTMLImageElement;\n\n        if (!resource) return;\n\n        // WebGPU does not support HTMLImageElement\n        // so we need to convert it to a canvas\n        if (globalThis.HTMLImageElement && resource instanceof HTMLImageElement)\n        {\n            const canvas = DOMAdapter.get().createCanvas(resource.width, resource.height);\n            const context = canvas.getContext('2d');\n\n            context.drawImage(resource, 0, 0, resource.width, resource.height);\n\n            // replace with the canvas - for future uploads\n            source.resource = canvas;\n\n            // #if _DEBUG\n            warn('ImageSource: Image element passed, converting to canvas and replacing resource.');\n            // #endif\n        }\n\n        const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n        const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        gpu.device.queue.copyExternalImageToTexture(\n            { source: resource },\n            { texture: gpuTexture, premultipliedAlpha },\n            {\n                width,\n                height,\n            }\n        );\n    }\n} as GpuTextureUploader<TextureSource>;\n\n","import { gpuUploadImageResource } from './gpuUploadImageSource';\n\nimport type { VideoSource } from '../../../shared/texture/sources/VideoSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadVideoResource = {\n\n    type: 'video',\n\n    upload(source: VideoSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        gpuUploadImageResource.upload(source, gpuTexture, gpu);\n    }\n} as GpuTextureUploader<VideoSource>;\n\n","/**\n * A class which generates mipmaps for a GPUTexture.\n * Thanks to toji for the original implementation\n * https://github.com/toji/web-texture-tool/blob/main/src/webgpu-mipmap-generator.js\n * @category rendering\n * @ignore\n */\nexport class GpuMipmapGenerator\n{\n    public device: GPUDevice;\n    public sampler: GPUSampler;\n    public pipelines: Record<string, GPURenderPipeline>;\n\n    public mipmapShaderModule: any;\n\n    constructor(device: GPUDevice)\n    {\n        this.device = device;\n        this.sampler = device.createSampler({ minFilter: 'linear' });\n        // We'll need a new pipeline for every texture format used.\n        this.pipelines = {};\n    }\n\n    private _getMipmapPipeline(format: GPUTextureFormat)\n    {\n        let pipeline = this.pipelines[format];\n\n        if (!pipeline)\n        {\n            // Shader modules is shared between all pipelines, so only create once.\n            if (!this.mipmapShaderModule)\n            {\n                this.mipmapShaderModule = this.device.createShaderModule({\n                    code: /* wgsl */ `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `,\n                });\n            }\n\n            pipeline = this.device.createRenderPipeline({\n                layout: 'auto',\n                vertex: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'vertexMain',\n                },\n                fragment: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'fragmentMain',\n                    targets: [{ format }],\n                }\n            });\n\n            this.pipelines[format] = pipeline;\n        }\n\n        return pipeline;\n    }\n\n    /**\n     * Generates mipmaps for the given GPUTexture from the data in level 0.\n     * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n     * @returns {module:External.GPUTexture} - The originally passed texture\n     */\n    public generateMipmap(texture: GPUTexture)\n    {\n        const pipeline = this._getMipmapPipeline(texture.format);\n\n        if (texture.dimension === '3d' || texture.dimension === '1d')\n        {\n            throw new Error('Generating mipmaps for non-2d textures is currently unsupported!');\n        }\n\n        let mipTexture = texture;\n        const arrayLayerCount = texture.depthOrArrayLayers || 1; // Only valid for 2D textures.\n\n        // If the texture was created with RENDER_ATTACHMENT usage we can render directly between mip levels.\n        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n\n        if (!renderToSource)\n        {\n            // Otherwise we have to use a separate texture to render into. It can be one mip level smaller than the source\n            // texture, since we already have the top level.\n            const mipTextureDescriptor = {\n                size: {\n                    width: Math.ceil(texture.width / 2),\n                    height: Math.ceil(texture.height / 2),\n                    depthOrArrayLayers: arrayLayerCount,\n                },\n                format: texture.format,\n                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n                mipLevelCount: texture.mipLevelCount - 1,\n            };\n\n            mipTexture = this.device.createTexture(mipTextureDescriptor);\n        }\n\n        const commandEncoder = this.device.createCommandEncoder({});\n        // TODO: Consider making this static.\n        const bindGroupLayout = pipeline.getBindGroupLayout(0);\n\n        for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer)\n        {\n            let srcView = texture.createView({\n                baseMipLevel: 0,\n                mipLevelCount: 1,\n                dimension: '2d',\n                baseArrayLayer: arrayLayer,\n                arrayLayerCount: 1,\n            });\n\n            let dstMipLevel = renderToSource ? 1 : 0;\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                const dstView = mipTexture.createView({\n                    baseMipLevel: dstMipLevel++,\n                    mipLevelCount: 1,\n                    dimension: '2d',\n                    baseArrayLayer: arrayLayer,\n                    arrayLayerCount: 1,\n                });\n\n                const passEncoder = commandEncoder.beginRenderPass({\n                    colorAttachments: [{\n                        view: dstView,\n                        storeOp: 'store',\n                        loadOp: 'clear',\n                        clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    }],\n                });\n\n                const bindGroup = this.device.createBindGroup({\n                    layout: bindGroupLayout,\n                    entries: [{\n                        binding: 0,\n                        resource: this.sampler,\n                    }, {\n                        binding: 1,\n                        resource: srcView,\n                    }],\n                });\n\n                passEncoder.setPipeline(pipeline);\n                passEncoder.setBindGroup(0, bindGroup);\n                passEncoder.draw(3, 1, 0, 0);\n\n                passEncoder.end();\n\n                srcView = dstView;\n            }\n        }\n\n        // If we didn't render to the source texture, finish by copying the mip results from the temporary mipmap texture\n        // to the source.\n        if (!renderToSource)\n        {\n            const mipLevelSize = {\n                width: Math.ceil(texture.width / 2),\n                height: Math.ceil(texture.height / 2),\n                depthOrArrayLayers: arrayLayerCount,\n            };\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                commandEncoder.copyTextureToTexture({\n                    texture: mipTexture,\n                    mipLevel: i - 1,\n                }, {\n                    texture,\n                    mipLevel: i,\n                }, mipLevelSize);\n\n                mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n                mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n            }\n        }\n\n        this.device.queue.submit([commandEncoder.finish()]);\n\n        if (!renderToSource)\n        {\n            mipTexture.destroy();\n        }\n\n        return texture;\n    }\n}\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\nimport { CanvasPool } from '../../shared/texture/CanvasPool';\nimport { BindGroup } from '../shader/BindGroup';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource';\nimport { blockDataMap, gpuUploadCompressedTextureResource } from './uploaders/gpuUploadCompressedTextureResource';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture, Texture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuTextureUploader } from './uploaders/GpuTextureUploader';\n\n/**\n * The system that handles textures for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    public readonly managedTextures: TextureSource[] = [];\n\n    protected CONTEXT_UID: number;\n    private _gpuSources: Record<number, GPUTexture> = Object.create(null);\n    private _gpuSamplers: Record<string, GPUSampler> = Object.create(null);\n    private _bindGroupHash: Record<string, BindGroup> = Object.create(null);\n    private _textureViewHash: Record<string, GPUTextureView> = Object.create(null);\n\n    private readonly _uploads: Record<string, GpuTextureUploader> = {\n        image: gpuUploadImageResource,\n        buffer: gpuUploadBufferImageResource,\n        video: gpuUploadVideoResource,\n        compressed: gpuUploadCompressedTextureResource\n    };\n\n    private _gpu: GPU;\n    private _mipmapGenerator?: GpuMipmapGenerator;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_gpuSources');\n        renderer.renderableGC.addManagedHash(this, '_gpuSamplers');\n        renderer.renderableGC.addManagedHash(this, '_bindGroupHash');\n        renderer.renderableGC.addManagedHash(this, '_textureViewHash');\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    /**\n     * Initializes a texture source, if it has already been initialized nothing will happen.\n     * @param source - The texture source to initialize.\n     * @returns The initialized texture source.\n     */\n    public initSource(source: TextureSource): GPUTexture\n    {\n        if (this._gpuSources[source.uid])\n        {\n            return this._gpuSources[source.uid];\n        }\n\n        return this._initSource(source);\n    }\n\n    private _initSource(source: TextureSource): GPUTexture\n    {\n        if (source.autoGenerateMipmaps)\n        {\n            const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n\n        if (source.uploadMethodId !== 'compressed')\n        {\n            usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n            usage |= GPUTextureUsage.COPY_SRC;\n        }\n\n        const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\n        const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n        const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n\n        const textureDescriptor: GPUTextureDescriptor = {\n            label: source.label,\n            size: { width, height },\n            format: source.format,\n            sampleCount: source.sampleCount,\n            mipLevelCount: source.mipLevelCount,\n            dimension: source.dimension,\n            usage\n        };\n\n        const gpuTexture = this._gpuSources[source.uid] = this._gpu.device.createTexture(textureDescriptor);\n\n        if (!this.managedTextures.includes(source))\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceResize, this);\n            source.on('destroy', this.onSourceDestroy, this);\n            source.on('unload', this.onSourceUnload, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n\n            this.managedTextures.push(source);\n        }\n\n        this.onSourceUpdate(source);\n\n        return gpuTexture;\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gpuTexture = this.getGpuSource(source);\n\n        // destroyed!\n        if (!gpuTexture) return;\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source);\n        }\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        const gpuTexture = this._gpuSources[source.uid];\n\n        if (gpuTexture)\n        {\n            this._gpuSources[source.uid] = null;\n\n            gpuTexture.destroy();\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource): void\n    {\n        if (!this._mipmapGenerator)\n        {\n            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n        }\n\n        const gpuTexture = this.getGpuSource(source);\n\n        this._mipmapGenerator.generateMipmap(gpuTexture);\n    }\n\n    protected onSourceDestroy(source: TextureSource): void\n    {\n        source.off('update', this.onSourceUpdate, this);\n        source.off('unload', this.onSourceUnload, this);\n        source.off('destroy', this.onSourceDestroy, this);\n        source.off('resize', this.onSourceResize, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n\n        this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n\n        this.onSourceUnload(source);\n    }\n\n    protected onSourceResize(source: TextureSource): void\n    {\n        const gpuTexture = this._gpuSources[source.uid];\n\n        if (!gpuTexture)\n        {\n            this.initSource(source);\n        }\n        else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight)\n        {\n            this._textureViewHash[source.uid] = null;\n            this._bindGroupHash[source.uid] = null;\n\n            this.onSourceUnload(source);\n            this.initSource(source);\n        }\n    }\n\n    private _initSampler(sampler: TextureStyle): GPUSampler\n    {\n        this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n\n        return this._gpuSamplers[sampler._resourceId];\n    }\n\n    public getGpuSampler(sampler: TextureStyle): GPUSampler\n    {\n        return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGpuSource(source: TextureSource): GPUTexture\n    {\n        return this._gpuSources[source.uid] || this.initSource(source);\n    }\n\n    /**\n     * this returns s bind group for a specific texture, the bind group contains\n     * - the texture source\n     * - the texture style\n     * - the texture matrix\n     * This is cached so the bind group should only be created once per texture\n     * @param texture - the texture you want the bindgroup for\n     * @returns the bind group for the texture\n     */\n    public getTextureBindGroup(texture: Texture)\n    {\n        return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);\n    }\n\n    private _createTextureBindGroup(texture: Texture)\n    {\n        const source = texture.source;\n\n        this._bindGroupHash[texture.uid] = new BindGroup({\n            0: source,\n            1: source.style,\n            2: new UniformGroup({\n                uTextureMatrix: { type: 'mat3x3<f32>', value: texture.textureMatrix.mapCoord },\n            })\n        });\n\n        return this._bindGroupHash[texture.uid];\n    }\n\n    public getTextureView(texture: BindableTexture)\n    {\n        const source = texture.source;\n\n        return this._textureViewHash[source.uid] ?? this._createTextureView(source);\n    }\n\n    private _createTextureView(texture: TextureSource)\n    {\n        this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();\n\n        return this._textureViewHash[texture.uid];\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const renderer = this._renderer;\n\n        const commandEncoder = renderer.gpu.device.createCommandEncoder();\n\n        // create canvas\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = texture.source.pixelWidth;\n        canvas.height = texture.source.pixelHeight;\n\n        const context = canvas.getContext('webgpu') as unknown as GPUCanvasContext;\n\n        context.configure({\n            device: renderer.gpu.device,\n\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n            format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),\n            alphaMode: 'premultiplied',\n        });\n\n        commandEncoder.copyTextureToTexture({\n            texture: renderer.texture.getGpuSource(texture.source),\n            origin: {\n                x: 0,\n                y: 0,\n            },\n        }, {\n            texture: context.getCurrentTexture(),\n        }, {\n            width: canvas.width,\n            height: canvas.height,\n        });\n\n        renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const webGPUCanvas = this.generateCanvas(texture);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n\n        const context = canvasAndContext.context;\n\n        context.drawImage(webGPUCanvas, 0, 0);\n\n        const { width, height } = webGPUCanvas;\n\n        const imageData = context.getImageData(0, 0, width, height);\n\n        const pixels = new Uint8ClampedArray(imageData.data.buffer);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return { pixels, width, height };\n    }\n\n    public destroy(): void\n    {\n        // we copy the array as the aarry with a slice as onSourceDestroy\n        // will remove the source from the real managedTextures array\n        this.managedTextures\n            .slice()\n            .forEach((source) => this.onSourceDestroy(source));\n\n        (this.managedTextures as null) = null;\n\n        for (const k of Object.keys(this._bindGroupHash))\n        {\n            const key = Number(k);\n            const bindGroup = this._bindGroupHash[key];\n\n            bindGroup?.destroy();\n            this._bindGroupHash[key] = null;\n        }\n\n        this._gpu = null;\n        this._mipmapGenerator = null;\n        this._gpuSources = null;\n        this._bindGroupHash = null;\n        this._textureViewHash = null;\n        this._gpuSamplers = null;\n    }\n}\n","import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { GpuGraphicsAdaptor } from '../../../scene/graphics/gpu/GpuGraphicsAdaptor';\nimport { GpuMeshAdapter } from '../../../scene/mesh/gpu/GpuMeshAdapter';\nimport { GpuBatchAdaptor } from '../../batcher/gpu/GpuBatchAdaptor';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer';\nimport { SharedRenderPipes, SharedSystems } from '../shared/system/SharedSystems';\nimport { RendererType } from '../types';\nimport { BindGroupSystem } from './BindGroupSystem';\nimport { GpuBufferSystem } from './buffer/GpuBufferSystem';\nimport { GpuColorMaskSystem } from './GpuColorMaskSystem';\nimport { type GPU, GpuDeviceSystem } from './GpuDeviceSystem';\nimport { GpuEncoderSystem } from './GpuEncoderSystem';\nimport { GpuLimitsSystem } from './GpuLimitsSystem';\nimport { GpuStencilSystem } from './GpuStencilSystem';\nimport { GpuUboSystem } from './GpuUboSystem';\nimport { GpuUniformBatchPipe } from './GpuUniformBatchPipe';\nimport { PipelineSystem } from './pipeline/PipelineSystem';\nimport { GpuRenderTargetSystem } from './renderTarget/GpuRenderTargetSystem';\nimport { GpuShaderSystem } from './shader/GpuShaderSystem';\nimport { GpuStateSystem } from './state/GpuStateSystem';\nimport { GpuTextureSystem } from './texture/GpuTextureSystem';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { PipeConstructor } from '../shared/instructions/RenderPipe';\nimport type { SharedRendererOptions } from '../shared/system/SharedSystems';\nimport type { SystemConstructor } from '../shared/system/System';\nimport type { ExtractRendererOptions, ExtractSystemTypes } from '../shared/system/utils/typeUtils';\n\nconst DefaultWebGPUSystems = [\n    ...SharedSystems,\n    GpuUboSystem,\n    GpuEncoderSystem,\n    GpuDeviceSystem,\n    GpuLimitsSystem,\n    GpuBufferSystem,\n    GpuTextureSystem,\n    GpuRenderTargetSystem,\n    GpuShaderSystem,\n    GpuStateSystem,\n    PipelineSystem,\n    GpuColorMaskSystem,\n    GpuStencilSystem,\n    BindGroupSystem,\n];\nconst DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\n\n// installed systems will bbe added to this array by the extensions manager..\nconst systems: { name: string; value: SystemConstructor }[] = [];\nconst renderPipes: { name: string; value: PipeConstructor }[] = [];\nconst renderPipeAdaptors: { name: string; value: any }[] = [];\n\nextensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);\n\n// add all the default systems as well as any user defined ones from the extensions\nextensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\n\n/**\n * The default WebGPU systems. These are the systems that are added by default to the WebGPURenderer.\n * @category rendering\n * @standard\n * @interface\n */\nexport type WebGPUSystems = ExtractSystemTypes<typeof DefaultWebGPUSystems> &\nPixiMixins.RendererSystems &\nPixiMixins.WebGPUSystems;\n\n/**\n * The WebGPU renderer pipes. These are used to render the scene.\n * @see {@link WebGPURenderer}\n * @internal\n */\nexport type WebGPUPipes = ExtractSystemTypes<typeof DefaultWebGPUPipes> &\nPixiMixins.RendererPipes &\nPixiMixins.WebGPUPipes;\n\n/**\n * Options for WebGPURenderer.\n * @category rendering\n * @standard\n */\nexport interface WebGPUOptions extends\n    SharedRendererOptions,\n    ExtractRendererOptions<typeof DefaultWebGPUSystems>,\n    PixiMixins.WebGPUOptions{}\n\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>,\n    WebGPUSystems {}\n\n/* eslint-disable max-len */\n/**\n * The WebGPU PixiJS Renderer. This renderer allows you to use the next-generation graphics API, WebGPU.\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGPURenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n * ```ts\n * import { autoDetectRenderer } from 'pixi.js';\n * // Create a new renderer\n * const renderer = await autoDetectRenderer();\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGPU renderer:\n *\n * | WebGPU Core Systems                      | Systems that are specific to the WebGL renderer                               |\n * | ---------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link GpuUboSystem}           | This manages WebGPU uniform buffer objects feature for shaders                |\n * | {@link GpuEncoderSystem}       | This manages the WebGPU command encoder                                       |\n * | {@link GpuDeviceSystem}        | This manages the WebGPU Device and its extensions                             |\n * | {@link GpuBufferSystem}        | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link GpuTextureSystem}       | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link GpuRenderTargetSystem}  | This manages what we render too. For example the screen, or another texture   |\n * | {@link GpuShaderSystem}        | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link GpuStateSystem}         | This manages the state of the WebGPU Pipelines. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link PipelineSystem}         | This manages the WebGPU pipelines, used for rendering                         |\n * | {@link GpuColorMaskSystem}     | This manages the color mask. Used for color masking                           |\n * | {@link GpuStencilSystem}       | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link BindGroupSystem}        | This manages the WebGPU bind groups. this is how data is bound to a shader when rendering |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @category rendering\n * @standard\n * @property {GpuUboSystem} ubo - UboSystem instance.\n * @property {GpuEncoderSystem} encoder - EncoderSystem instance.\n * @property {GpuDeviceSystem} device - DeviceSystem instance.\n * @property {GpuBufferSystem} buffer - BufferSystem instance.\n * @property {GpuTextureSystem} texture - TextureSystem instance.\n * @property {GpuRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {GpuShaderSystem} shader - ShaderSystem instance.\n * @property {GpuStateSystem} state - StateSystem instance.\n * @property {PipelineSystem} pipeline - PipelineSystem instance.\n * @property {GpuColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @property {GpuStencilSystem} stencil - StencilSystem instance.\n * @property {BindGroupSystem} bindGroup - BindGroupSystem instance.\n * @extends AbstractRenderer\n */\nexport class WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>\n    implements WebGPUSystems\n{\n    /** The WebGPU Device. */\n    public gpu: GPU;\n\n    constructor()\n    {\n        const systemConfig = {\n            name: 'webgpu',\n            type: RendererType.WEBGPU,\n            systems,\n            renderPipes,\n            renderPipeAdaptors,\n        };\n\n        super(systemConfig);\n    }\n}\n"],"names":["GpuGraphicsAdaptor","constructor","_maxTextures","contextChange","renderer","localUniforms","UniformGroup","uTransformMatrix","value","Matrix","type","uColor","Float32Array","uRound","limits","maxBatchableTextures","gpuProgram","compileHighShaderGpuProgram","name","bits","colorBit","generateTextureBatchBit","this","localUniformBitGroup2","roundPixelsBit","shader","Shader","resources","execute","graphicsPipe","renderable","context","customShader","contextSystem","graphicsContext","batcher","instructions","getContextRenderData","encoder","setGeometry","geometry","globalUniformsBindGroup","globalUniforms","bindGroup","setBindGroup","localBindGroup","renderPipes","uniformBatch","getUniformBindGroup","batches","topology","i","instructionSize","batch","setPipelineFromGeometryProgramAndState","state","groups","gpuBindGroup","textureBatch","textures","getTextureBatchBindGroup","count","getBindGroup","renderPassEncoder","drawIndexed","size","start","destroy","extension","ExtensionType","WebGPUPipesAdaptor","GpuMeshAdapter","init","localUniformBit","textureBit","_shader","uTexture","Texture","EMPTY","_source","uSampler","style","textureUniforms","uTextureMatrix","meshPipe","mesh","warn","texture","getTextureBindGroup","autoAssignGlobalUniforms","autoAssignLocalUniforms","draw","_geometry","tempState","State","for2d","GpuBatchAdaptor","batchPipe","program","blendMode","pipeline","getPipeline","resetBindGroup","_touch","textureGC","setPipeline","BindGroupSystem","_hash","Object","create","_renderer","renderableGC","addManagedHash","gpu","_gpu","groupIndex","_updateKey","_key","_createBindGroup","group","device","groupLayout","layout","entries","j","_group$resources$j","resource","gpuResource","_resourceType","uniformGroup","ubo","updateUniformGroup","buffer","getGPUBuffer","offset","descriptor","bufferResource","sampler","getGpuSampler","getGpuSource","createView","push","binding","getProgramData","bindGroups","createBindGroup","key","keys","WebGPUSystem","GpuBufferSystem","_gpuBuffers","_managedBuffers","uid","createGPUBuffer","updateBuffer","gpuBuffer","data","_updateID","queue","writeBuffer","_updateSize","byteLength","destroyAll","id","on","onBufferChange","onBufferDestroy","createBuffer","fastCopy","getMappedRange","unmap","splice","indexOf","_destroyBuffer","forEach","off","GpuColorMaskSystem","_colorMaskCache","setMask","colorMask","setColorMask","GpuDeviceSystem","options","_initPromise","Promise","resolve","_createDeviceAndAdaptor","then","runners","emit","adapter","DOMAdapter","get","getNavigator","requestAdapter","powerPreference","forceFallbackAdapter","requiredFeatures","filter","feature","features","has","requestDevice","defaultOptions","GpuEncoderSystem","_boundBindGroup","_boundVertexBuffer","renderStart","commandFinished","_resolveCommandFinished","commandEncoder","createCommandEncoder","beginRenderPass","gpuRenderTarget","endRenderPass","_clearCache","end","setViewport","viewport","x","y","width","height","_boundPipeline","_setVertexBuffer","index","setVertexBuffer","_setIndexBuffer","_boundIndexBuffer","indexFormat","BYTES_PER_ELEMENT","setIndexBuffer","buffersToBind","getBufferNamesToBind","parseInt","attributes","indexBuffer","_setShaderBindGroups","skipSync","_syncBindGroup","isUniformGroup","instanceCount","length","getSize","finishRenderPass","postrender","submit","finish","restoreRenderPass","renderTarget","adaptor","getDescriptor","boundPipeline","boundVertexBuffer","_objectSpread","boundIndexBuffer","boundBindGroup","priority","GpuLimitsSystem","maxTextures","maxSampledTexturesPerShaderStage","GpuStencilSystem","_renderTargetStencilState","onRenderTargetChange","add","stencilState","stencilMode","STENCIL_MODES","DISABLED","stencilReference","_activeRenderTarget","setStencilMode","setStencilReference","remove","WGSL_ALIGN_SIZE_DATA","i32","align","u32","f32","f16","createUboElementsWGSL","uniformData","uboElements","map","uboElement","Error","concat","Math","max","ceil","generateArraySyncWGSL","offsetToAdd","remainder","createUboSyncFunctionWGSL","createUboSyncFunction","uboSyncFunctionsWGSL","GpuUboSystem","UboSystem","createUboElements","generateUboSync","UboBatch","_ref","minUniformOffsetAlignment","_minUniformOffsetAlignment","byteIndex","clear","addEmptyGroup","newSize","addGroup","array","GpuUniformBatchPipe","_bindGroupHash","_buffers","_bindGroups","_bufferResources","_batchBuffer","usage","BufferUsage","UNIFORM","COPY_DST","COPY_SRC","Buffer","renderEnd","_uploadBindGroups","_resetBindGroups","duplicate","ensureUniformGroup","syncUniformGroup","_getBindGroup","getUboResource","_getBufferResource","getArrayBindGroup","getArrayBufferResource","BufferResource","BindGroup","bufferSystem","firstBuffer","update","copyBufferToBuffer","_this$_bindGroups$i","WebGPUPipes","topologyStringToId","PipelineSystem","_moduleCache","_bufferLayoutsCache","_bindingNamesCache","_pipeCache","_pipeStateCaches","_colorMask","_multisampleCount","_updatePipeHash","setMultisampleCount","multisampleCount","setRenderTarget","msaaSamples","_depthStencilAttachment","depthStencilAttachment","_stencilMode","_stencilState","GpuStencilModesToPixi","passEncoder","_layoutKey","ensureAttributes","attributeData","_generateBufferKey","geometryLayout","shaderKey","getGraphicsStateKey","_blendModeId","_createPipeline","buffers","_createVertexBufferLayouts","blendModes","getColorTargets","writeMask","RENDERING_MASK_ADD","vertex","module","_getModule","source","entryPoint","fragment","targets","primitive","cullMode","multisample","label","depthStencil","format","depthWriteEnabled","depthTest","depthCompare","createRenderPipeline","code","_createModule","createShaderModule","keyGen","attributeKeys","sort","attribute","stride","instance","stringKey","join","createIdFromString","_generateAttributeLocationsKey","location","_attributeLocationsKey","bufferNamesToBind","shaderLocation","values","vertexBuffersLayout","bufferEntry","arrayStride","stepMode","bufferEntryAttributes","_attribute$divisor","divisor","stencilStateId","multiSampleCount","GpuRenderTarget","contexts","msaaTextures","GpuRenderTargetAdaptor","renderTargetSystem","_renderTargetSystem","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","baseGpuTexture","_getGpuColorTexture","backGpuTexture","copyTextureToTexture","origin","startRenderPass","arguments","undefined","clearColor","getGpuRenderTarget","getCurrentTexture","colorTextures","clearValue","CLEAR","ALL","NONE","colorAttachments","view","resolveTarget","mipLevelCount","getTextureView","loadOp","COLOR","defaultClearColor","storeOp","stencil","depth","depthStencilTexture","ensureDepthStencilTexture","sampleCount","msaa","stencilLoadOp","STENCIL","depthLoadOp","DEPTH","stencilStoreOp","depthClearValue","depthStoreOp","renderPassDescriptor","gpuCommands","initGpuRenderTarget","isRoot","colorTexture","CanvasSource","getContext","alphaMode","transparent","configure","GPUTextureUsage","TEXTURE_BINDING","RENDER_ATTACHMENT","e","console","error","antialias","msaaTexture","TextureSource","destroyGpuRenderTarget","unconfigure","resizeGpuRenderTarget","resize","_resolution","GpuRenderTargetSystem","RenderTargetSystem","super","GpuShaderSystem","_gpuProgramData","_createGPUProgramData","gpuLayout","createBindGroupLayout","pipelineLayoutDesc","bindGroupLayouts","createPipelineLayout","GpuBlendModesToPixi","alpha","srcFactor","dstFactor","operation","color","GpuStateSystem","defaultState","blend","normal","gpuUploadBufferImageResource","upload","gpuTexture","total","pixelWidth","pixelHeight","bytesPerPixel","writeTexture","rowsPerImage","bytesPerRow","depthOrArrayLayers","blockDataMap","blockBytes","blockWidth","blockHeight","defaultBlockData","gpuUploadCompressedTextureResource","mipWidth","mipHeight","blockData","levelBuffer","mipLevel","gpuUploadImageResource","globalThis","HTMLImageElement","canvas","createCanvas","drawImage","min","resourceWidth","resourceHeight","premultipliedAlpha","copyExternalImageToTexture","gpuUploadVideoResource","GpuMipmapGenerator","createSampler","minFilter","pipelines","_getMipmapPipeline","mipmapShaderModule","generateMipmap","dimension","mipTexture","arrayLayerCount","renderToSource","mipTextureDescriptor","createTexture","bindGroupLayout","getBindGroupLayout","arrayLayer","srcView","baseMipLevel","baseArrayLayer","dstMipLevel","dstView","r","g","b","a","mipLevelSize","GpuTextureSystem","managedTextures","_gpuSources","_gpuSamplers","_textureViewHash","_uploads","image","video","compressed","initSource","_initSource","autoGenerateMipmaps","biggestDimension","floor","log2","uploadMethodId","textureDescriptor","includes","onSourceUpdate","onSourceResize","onSourceDestroy","onSourceUnload","onUpdateMipmaps","_mipmapGenerator","_initSampler","_resourceId","_this$_bindGroupHash$","_createTextureBindGroup","textureMatrix","mapCoord","_this$_textureViewHas","_createTextureView","generateCanvas","getPreferredCanvasFormat","getPixels","webGPUCanvas","canvasAndContext","CanvasPool","getOptimalCanvasAndContext","imageData","getImageData","pixels","Uint8ClampedArray","returnCanvasAndContext","slice","k","Number","DefaultWebGPUSystems","SharedSystems","DefaultWebGPUPipes","SharedRenderPipes","DefaultWebGPUAdapters","systems","renderPipeAdaptors","extensions","handleByNamedList","WebGPURenderer","AbstractRenderer","RendererType","WEBGPU"],"sourceRoot":""}